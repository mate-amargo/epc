# =============================================================================
# epc - Easy Prompt Changer
# =============================================================================
# Made by jarg
# =============================================================================
# Version 0.7
# 30 Julio 2009
# Start time 20:45
# Stop time 23:35
# Changelog:
# Arreglado cambiar un prompt en el caso de que el archivo tenga comentarios
# Reescrito cambiar un prompt, quedo mas corto y mas simple
# Hecho el codigo de borrar un prompt
# =============================================================================

epc () {

# Variables locales a esta funcion
local scrname="epc" scrver="0.7"
local savefile=~/.prompts
local aux="" P="" space=""
local i=0
local base="\[\e["
local pname=""

case $1 in
  -h | --help) # Imprime la ayuda y sale
    echo ""
    return 0 # return sale de la funcion y devuelve un exitcode al parent
    ;;
  -v | --version) # Imprime la version y sale
    echo $scrname-$scrver
    return 0
    ;;
  -l | --list) # Muestra una lista de los prompts disponibles
    if [ ! -f "$savefile" ]; then
      echo "No existe una lista de prompts"
      echo "La lista se crea automaticamente al guardar un prompt (opcion -s)"
      return 2
    else
      sed -n '/^:/p' $savefile | \
      awk -F ":" 'BEGIN {print "Lista de prompts almacenados actualmente\n\n \
      \tNumero\t\tNombre\t\tVista Previa\n \
      \t======\t\t======\t\t============\n"}\
      { num = num + 1 }\
      {print "\t"num"\t\t"$2"\t\t"$4"\n"}'
    fi
    ;;
  -c | --change) # Cambia el prompt actual por uno de la lista
    if (( $# == 1)); then
      echo "Especifique un numero o un nombre de prompt a cambiar por favor"
      return 1
    else
      pname="$2" ; shift 2
      while (( $# != 0 )) ; do
        pname="$pname ""$1"
        shift
      done
      aux=$(echo $pname | cut -d " " -f 1); declare -i aux=$aux; #Si pname era una string, aux=0
      if (( $aux != 0 )); then # El tipo ingreso un numero de prompt
        # awk -F : = awk -F: = awk -F ":" = awk 'BEGIN {FS=":"}'
        # sed -n '/^:/p' saca todos los comentarios y basuras del archivo
        P="$(sed -n '/^:/p' $savefile | awk -F: '{num = num+1}{print num,$3}' \
        | grep "$pname " | cut -d " " -f 2-)" # el espacio de "$pname " es vital para encontrar
                                              # pname y ademas encontrarlo exactamente
      else  # El tipo ingreso un nombre de prompt
        P="$(sed -n '/^:/p' $savefile | awk -F: '{print $2,$3}' \
        | grep -m 1 "$pname " | awk -F "$pname " '{print $2}' )" # grep -m 1 stopts at 1st match
      fi
      if [ -n "$P" ]; then # Si P no esta vacia
        export PS1="$P"
        echo -e "\033[32mPrompt cambiado exitosamente!\033[0m"
        return 0
      else
        echo -e "\033[31mNo se encontro el prompt $pname en la lista de prompts\033[0m"
        return 2
      fi
    fi
    ;;
  -m | --make) # Crea un nuevo prompt
    if (( $# == 1 )); then
      echo -e "\033[1;31mUso incorrecto. Faltan argumentos\033[0m\n"
      echo "Uso de $scrname con la opcion -m:"
      echo "$scrname -m [CARACTER DE ESPACIO] CONSTRUCTORES"
      echo "La opcion entre [] sirve para espicificar un caracter que al ser ingresado"
      echo "sera reemplazado por un espacio en el prompt resultante."
      echo "Esto es asi, ya que el constructor del prompt no reconoce los espacios,"
      echo "por lo tanto hay que utilizar otro caracter a su eleccion."
      echo "Recuerde que el 1er parametro luego de -m se tomara como el CARACTER DE"
      echo "ESPACIO, a menos que este sea el unico parametro luego de -m. En ese caso"
      echo -e "sera usado como el prompt. A continuacion algunos ejemplos:\n"
      echo "Usando '_' como caracter de espacio"
      echo "$scrname -m _ lbgreen user @ host _ [ _ white wdir lbgreen _ ] _ sign _ normal"
      echo -e "Resultado:\033[1;32musuarionormal@localhost [\033[1;37m /usr/bin\033[1;32m ] $ \033[0m\n"
      echo "Especificando solo un parametro a $scrname -m"
      echo "$scrname -m #"
      echo -e "Resultado:#\n"
      echo "Para una lista detallada de los constructores y de otros modos de"
      echo "usar $scrname pruebe $scrname -h ó $scrname --help."
      echo "Para obtener informacion aún más detallada: info $scrname ó man $scrname"
      return 1
    elif
      (( $# == 2 )); then # Si solo se da un argumeto luego de la opcion -m
      P="$2"              # este se toma como unico caracter del prompt
    fi                    # De no ser asi (se dan mas de 1 argumento luego de -m)
    space="$2"            # Entonces se usa el 1 parametro (despues de -m) como caracter de espacio
                          # Y se procesan los siguientes parametros
    shift 2 # Saca los n primeros argumentos argumentos
    while (( $# > 0 )); do
      let i=1
      while [[ $(echo $1 | awk '{print NR}') -eq i ]] ; do # Repetir hasta que no haya argumentos
        aux=$(echo $1 | awk '{print $'$i'}') # Esto separa una palabra con espacios a ambos lados
        case $aux in                         # Y se la asigna a aux
          # Colores!!!

          # Foreground                                        Background
          white)      P="$P""$base""0m\]" ;;
          black)      P="$P""$base""30m\]" ;;      bblack)     P="$P""$base""40m\]" ;;
          red)        P="$P""$base""31m\]" ;;      bred)       P="$P""$base""41m\]" ;;
          green)      P="$P""$base""32m\]" ;;      bgreen)     P="$P""$base""42m\]" ;;
          brown)      P="$P""$base""33m\]" ;;      bbrown)     P="$P""$base""43m\]" ;;
          blue)       P="$P""$base""34m\]" ;;      bblue)      P="$P""$base""44m\]" ;;
          purple)     P="$P""$base""35m\]" ;;      bpurple)    P="$P""$base""45m\]" ;;
          cyan)       P="$P""$base""36m\]" ;;      bcyan)      P="$P""$base""46m\]" ;;
          lightgray)  P="$P""$base""37m\]" ;;      blightgray) P="$P""$base""47m\]" ;;

          # Efectos de texto !!! :-o
          normal)     P="$P""$base""0m\]" ;;       bold)       P="$P""$base""1m\]" ;;
          underscore) P="$P""$base""4m\]" ;;       blink)      P="$P""$base""5m\]" ;;
          inverse)    P="$P""$base""7m\]" ;;       invisible)  P="$P""$base""8m\]" ;;

          # Chucherias!!!

          $space)   P="$P " ;;
          bell)     P="$P\a" ;;
          host)     P="$P\h" ;;
          hostfull) P="$P\H" ;;
          jobs)     P="$P\j" ;;
          terminal) P="$P\l" ;;
          newline)  P="$P\n" ;;
          creturn)  P="$P\r" ;;
          shell)    P="$P\s" ;;
          user)     P="$P\u" ;;
          version)  P="$P\v" ;;
          realese)  P="$P\V" ;;
          wdir)     P="$P\w" ;;
          Wdir)     P="$P\W" ;;
          hisnum)   P="$P\!" ;;
          cmdnum)   P="$P\#" ;;
          exitcode) P="$P\$?" ;;
          sign)     P="$P\$ " ;;
          date)     P="$P\$(date +%D)" ;;
          "(")      P="$P""(" ;;
          ")")      P="$P"")" ;;
          *)        P="$P""$aux" ;;
        esac
        let i=$i+1
      done
      shift
    done
    export PS1="$P"
    ;;
  -s | --save) # Guardar el prompt actual en la lista de prompts conocidos
    if [ -z $2 ]; then
      echo "Debe especificar un nombre para guardar el prompt actual"
      return 1
    fi
    pname=$2 ; shift 2
    while (( $# != 0 )) ; do
      pname="$pname ""$1"
      shift
    done
   aux="$pname"
  if [ -f $savefile ] && (( $( awk 'BEGIN {FS=":"} {print $2}' $savefile | grep -m 1 "$aux" | wc -l) >= 1 )); then
    aux=$(echo $pname | cut -d " " -f 1); declare -i i=$aux; aux="$pname"
    while [ "$pname" == "$aux" ] || ((i != 0)) || ([ -f $savefile ] && \
    (( $( awk 'BEGIN {FS=":"} {print $2}' $savefile | grep -m 1 "$aux" | wc -l) >= 1 ))); do
     trap 'echo -e "\033[31m\b\b  \nEl propmt no ha sido guardado porque se recibio una señal de terminar\033[0m\n"; return 3 ' SIGINT SIGTERM
     echo
     if [ -f $savefile ] && (( $( awk 'BEGIN {FS=":"} {print $2}' $savefile | grep -m 1 "$aux" | wc -l) >= 1 )); then
       echo -e "\033[31mYa existe un prompt con el nombre $aux\033[0m\n"
     fi
     if ((i != 0)); then echo "No esta permitido que el nombre sea un numero"; fi
     echo -n "Por favor ingrese un nombre distinto (CTRL-C para cancelar): "
     read aux
     aux=$(echo $aux | cut -d " " -f 1); declare -i i=$aux;
    done
   fi
    [[ -f $savefile ]] || install -m u+rw-x,g-rwx,o-rwx -T /dev/null $savefile
    echo ":$aux:$PS1:$(echo -e $PS1 | sed -e 's/\\\[//g' -e 's/\\]//g' -e 's/\\l/tty1/g' -e 's/\\u/user/g' -e 's/\\h/host/g' -e 's/\\w/~\/ejemplo/g')" >> $savefile
    echo "El prompt actual se ha guardado satisfactoriamente en $savefile"
    return 0
    ;;
  -b | --bashrc) # Hacer que el prompt actual sea el prompt por defecto
    ;;
  -d | --delete) # Borra un prompt de la lista
    if (( $# == 1)); then
      echo "Especifique un numero o un nombre de prompt para borrar"
      return 1
    else
      pname="$2" ; shift 2
      while (( $# != 0 )) ; do
        pname="$pname ""$1"
        shift
      done
      aux=$(echo $pname | cut -d " " -f 1); declare -i aux=$aux; #Si pname era una string, aux=0
      if (( $aux != 0 )); then # El tipo ingreso un numero
        P="$(awk '{num = num+1}{print $0,num}' $savefile | sed -n '/^:/p' | \
        sed -n "$pname"p | awk -F " " '{print $NF}')" #NF= number of fields => $NF imprime el ultimo
      else  # El tipo ingreso un nombre de prompt
        P="$(awk '{num = num+1}{print $0,num}' $savefile | sed -n '/^:/p' | \
        grep -m 1 ":$pname:" | awk -F " " '{print $NF}')" # grep -m 1 stopts at 1st match
      fi
      if [ -n "$P" ]; then
        sed -i "$P"d $savefile
        if (( $(sed -n '/^:/p' $savefile | wc -l) == 0 )); then #Si el prompt que acaba de borrarse
          rm -f $savefile # era el ultimo de la lista => borra el archivo
        fi
        echo -e "\033[32mPrompt borrado exitosamente!\033[0m"
        return 0
      else
       echo -e "\033[31mNo se encontro el prompt $pname en la lista de prompts\033[0m"
       return 2
      fi
    fi
    ;;
  *) # else, case else
    echo -e "\033[1;31mOpcion o argumento invalido\033[0m"
    echo "Para ver brevemente las opciones de este comando usar:"
    echo "$scrname -h ó $scrname --help."
    echo "Para mas ayuda refierase al manual, man $scrname ó info $scrname"
    return 1
    ;;
esac

}
