# =============================================================================
# epc - Easy Prompt Changer
# =============================================================================
# Made by jarg
# =============================================================================
# Version 0.4
# 28 Julio 2009
# Start time 22:52
# Stop time 29 Julio 2009 02:30
# Changelog:
# Se arreglo el codigo de cambiar un promt
# Se cambio la forma en que se guardan los prompts
# No se permiten promts con nombres iguales
# =============================================================================

epc () {

# Variables locales a esta funcion
local scrname="epc" scrver="0.4"
local savefile=~/.prompts
local aux="" P="" space=""
local i=0
local base="\[\e["
local pname=""

case $1 in
  -h | --help) # Imprime la ayuda y sale
    echo ""
    return 0 # return sale de la funcion y devuelve un exitcode al parent
    ;;
  -v | --version) # Imprime la version y sale
    echo $scrname-$scrver
    return 0
    ;;
  -l | --list) # Muestra una lista de los prompts disponibles
    if [ ! -f "$savefile" ]; then
      echo "No existe una lista de prompts"
      echo "La lista se crea automaticamente al guardar un prompt (opcion -s)"
      return 2
    else
      awk -F ":" 'BEGIN {print "Lista de prompts almacenados actualmente\n\n \
      \tNumero\t\tNombre\t\tVista Previa\n \
      \t======\t\t======\t\t============\n"}\
      { num = num + 1 }\
      {print "\t"num"\t\t"$2"\t\t"$4"\n"}' $savefile
    fi
    ;;
  -c | --change) # Cambia el prompt actual por uno de la lista
    if (( $# == 1)); then
      echo "Especifique un numero o un nombre de prompt a cambiar por favor"
      return 1
    else
      pname="$2" ; shift 2
      while (( $# != 0 )) ; do
        pname="$pname ""$1"
        shift
      done
      if (($pname)); then # Si es un numero (($pname)) es 0 else 1
         export PS1="$(awk -F: '{num = num+1}{print num,$3 }' \
         $savefile | grep -m 1 ^$pname | cut -d " " -f 2-)"
                     # grep -m 1 se detiene desp de 1 encuentro
                     # awk -F : = awk -F: = awk -F ":" = awk 'BEGIN {FS=":"}'
        else
         export PS1="$(awk -F: '{print $2,$3}' $savefile | grep -x "$pname" | cut -d " " -f 2-)"
      fi
      echo "Prompt cambiado exitosamente!"
      return 0
    fi
    ;;
  -m | --make) # Crea un nuevo prompt
    if (( $# == 1 )); then
      echo -e "\033[1;31mUso incorrecto. Faltan argumentos\033[0m\n"
      echo "Uso de $scrname con la opcion -m:"
      echo "$scrname -m [CARACTER DE ESPACIO] CONSTRUCTORES"
      echo "La opcion entre [] sirve para espicificar un caracter que al ser ingresado"
      echo "sera reemplazado por un espacio en el prompt resultante."
      echo "Esto es asi, ya que el constructor del prompt no reconoce los espacios,"
      echo "por lo tanto hay que utilizar otro caracter a su eleccion."
      echo "Recuerde que el 1er parametro luego de -m se tomara como el CARACTER DE"
      echo "ESPACIO, a menos que este sea el unico parametro luego de -m. En ese caso"
      echo -e "sera usado como el prompt. A continuacion algunos ejemplos:\n"
      echo "Usando '_' como caracter de espacio"
      echo "$scrname -m _ lbgreen user @ host _ [ _ white wdir lbgreen _ ] _ sign _ normal"
      echo -e "Resultado:\033[1;32musuarionormal@localhost [\033[1;37m /usr/bin\033[1;32m ] $ \033[0m\n"
      echo "Especificando solo un parametro a $scrname -m"
      echo "$scrname -m #"
      echo -e "Resultado:#\n"
      echo "Para una lista detallada de los constructores y de otros modos de"
      echo "usar $scrname pruebe $scrname -h ó $scrname --help."
      echo "Para obtener informacion aún más detallada: info $scrname ó man $scrname"
      return 1
    elif
      (( $# == 2 )); then # Si solo se da un argumeto luego de la opcion -m
      P="$2"              # este se toma como unico caracter del prompt
    fi                    # De no ser asi (se dan mas de 1 argumento luego de -m)
    space="$2"            # Entonces se usa el 1 parametro (despues de -m) como caracter de espacio
                          # Y se procesan los siguientes parametros
    shift 2 # Saca los n primeros argumentos argumentos
    while (( $# > 0 )); do
      let i=1
      while [[ $(echo $1 | awk '{print NR}') -eq i ]] ; do # Repetir hasta que no haya argumentos
        aux=$(echo $1 | awk '{print $'$i'}') # Esto separa una palabra con espacios a ambos lados
        case $aux in                         # Y se la asigna a aux
          # Colores!!!

          # Foreground                                        Background
          white)      P="$P""$base""0m\]" ;;
          black)      P="$P""$base""30m\]" ;;      bblack)     P="$P""$base""40m\]" ;;
          red)        P="$P""$base""31m\]" ;;      bred)       P="$P""$base""41m\]" ;;
          green)      P="$P""$base""32m\]" ;;      bgreen)     P="$P""$base""42m\]" ;;
          brown)      P="$P""$base""33m\]" ;;      bbrown)     P="$P""$base""43m\]" ;;
          blue)       P="$P""$base""34m\]" ;;      bblue)      P="$P""$base""44m\]" ;;
          purple)     P="$P""$base""35m\]" ;;      bpurple)    P="$P""$base""45m\]" ;;
          cyan)       P="$P""$base""36m\]" ;;      bcyan)      P="$P""$base""46m\]" ;;
          lightgray)  P="$P""$base""37m\]" ;;      blightgray) P="$P""$base""47m\]" ;;

          # Efectos de texto !!! :-o
          normal)     P="$P""$base""0m\]" ;;       bold)       P="$P""$base""1m\]" ;;
          underscore) P="$P""$base""4m\]" ;;       blink)      P="$P""$base""5m\]" ;;
          inverse)    P="$P""$base""7m\]" ;;       invisible)  P="$P""$base""8m\]" ;;

          # Chucherias!!!

          $space)   P="$P " ;;
          bell)     P="$P\a" ;;
          host)     P="$P\h" ;;
          hostfull) P="$P\H" ;;
          jobs)     P="$P\j" ;;
          terminal) P="$P\l" ;;
          newline)  P="$P\n" ;;
          creturn)  P="$P\r" ;;
          shell)    P="$P\s" ;;
          user)     P="$P\u" ;;
          version)  P="$P\v" ;;
          realese)  P="$P\V" ;;
          wdir)     P="$P\w" ;;
          Wdir)     P="$P\W" ;;
          hisnum)   P="$P\!" ;;
          cmdnum)   P="$P\#" ;;
          exitcode) P="$P\$?" ;;
          sign)     P="$P\$ " ;;
          date)     P="$P\$(date +%D)" ;;
          "(")      P="$P""(" ;;
          ")")      P="$P"")" ;;
          *)        P="$P""$aux" ;;
        esac
        let i=$i+1
      done
      shift
    done
    export PS1="$P"
    ;;
  -s | --save) # Guardar el prompt actual en la lista de prompts conocidos
    if [ -z $2 ]; then
      echo "Debe especificar un nombre para guardar el prompt actual"
      return 1
    fi
    pname=$2 ; shift 2
    while (( $# != 0 )) ; do
      pname="$pname ""$1"
      shift
    done
    if (( $( awk 'BEGIN {FS=":"} {print $2}' $savefile | grep -x "$pname" | wc -l) > 1 )) ; then
      echo -e "Ya equiste un prompt con el nombre $pname\n"
      while [ "$pname" -ne "$old" ]; do
        echo -n "Por favor ingrese un nombre distinto: "
        read old
      done
    fi
    [[ -f $savefile ]] || install -m u+rw-x,g-rwx,o-rwx -T /dev/null $savefile
    echo ":$pname:$PS1:$(echo -e $PS1 | sed -e 's/\\\[//g' -e 's/\\]//g' -e 's/\\l/tty1/g' -e 's/\\u/user/g' -e 's/\\h/host/g' -e 's/\\w/~\/ejemplo/g')" >> $savefile
    echo "El prompt actual se ha guardado satisfactoriamente en $savefile"
    return 0
    ;;
  -b | --bashrc) # Hacer que el prompt actual sea el prompt por defecto
    ;;
  -d | --delete) # Borra un prompt de la lista
    ;;
  *) # else, case else
    echo -e "\033[1;31mOpcion o argumento invalido\033[0m"
    echo "Para ver brevemente las opciones de este comando usar:"
    echo "$scrname -h ó $scrname --help."
    echo "Para mas ayuda refierase al manual, man $scrname ó info $scrname"
    return 1
    ;;
esac

}
