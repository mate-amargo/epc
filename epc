# =============================================================================
# epc - Easy Prompt Changer
# =============================================================================
# Made by jarg
# =============================================================================
# Version 0.2
# 27 Julio 2009
# Start time 18:32
# Stop at 22:55
# First version
# Changelog:
# Terminada la parte principal de crear un prompt, mejorado el uso de colores
# totalmente reescrito. Ayuda echa mas clara. Resta agregarle mas
# funcionalidades en el apartado "Chucherias"
# Empezadas pobremente la parte de listar y cambiar un prompt
# =============================================================================

epc () {

# Variables locales a esta funcion
local scrname="epc" scrver="0.2"
local savefile=~/.prompts
local aux="" P="" space=""
local i=0
local base="\[\e["
local pname=""
local pnum=0

case $1 in
  -h | --help) # Imprime la ayuda y sale
    echo ""
    return 0 # return sale de la funcion y devuelve un exitcode al parent
    ;;
  -v | --version) # Imprime la version y sale
    echo $scrname-$scrver
    return 0
    ;;
  -l | --list) # Muestra una lista de los prompts disponibles
    if [ ! -f "$savefile" ]; then
      echo "No existe una lista de prompts"
      echo "La lista se crea automaticamente al guardar un prompt (opcion -s)"
      return 2
    else
      awk 'BEGIN {FS=":"} {print "Lista de prompts almacenados actualmente\n"} \
      {print "\t\tNumero\t\t\t\tNombre\n"}\
      {print "\t\t======\t\t\t\t======\n"}\
      {print "\t\t"$2"\t\t\t\t"$3"\n"}' $savefile
    fi
    ;;
  -c | --change) # Cambia el prompt actual por uno de la lista
    if (( $# == 1)); then
      echo "Especifique un numero o un nombre de prompt a cambiar por favor"
      return 1
    else
      let i=2
      while (( i <= $# )) ; do
        pname="$pname ""$'$i'"
        shift
      done
      if (( $(grep $pname | awk 'BEGIN {FS=":"} {print $3}' $savefile) | wc -l)) > 1 ; then
         echo "Se han encontrado varios resultados para el nombre ingresado"
         grep $pname | awk 'BEGIN {FS=":"} {print $3}' $savefile
         echo "Por favor ingrese el numero del prompt elegido"
         read i
         export PS1="$(grep $i $savefile)"
      fi
      echo "Prompt cambiado exitosamente!"
      return 0
    fi
    ;;
  -m | --make) # Crea un nuevo prompt
    if (( $# == 1 )); then
      echo -e "\033[1;31mUso incorrecto. Faltan argumentos\033[0m\n"
      echo "Uso de $scrname con la opcion -m:"
      echo "$scrname -m [CARACTER DE ESPACIO] CONSTRUCTORES"
      echo "La opcion entre [] sirve para espicificar un caracter que al ser ingresado"
      echo "sera reemplazado por un espacio en el prompt resultante."
      echo "Esto es asi, ya que el constructor del prompt no reconoce los espacios,"
      echo "por lo tanto hay que utilizar otro caracter a su eleccion."
      echo "Recuerde que el 1er parametro luego de -m se tomara como el CARACTER DE"
      echo "ESPACIO, a menos que este sea el unico parametro luego de -m. En ese caso"
      echo -e "sera usado como el prompt. A continuacion algunos ejemplos:\n"
      echo "Usando '_' como caracter de espacio"
      echo "$scrname -m _ lbgreen user @ host _ [ _ white wdir lbgreen _ ] _ sign _ normal"
      echo -e "Resultado:\033[1;32musuarionormal@localhost [\033[1;37m /usr/bin\033[1;32m ] $ \033[0m\n"
      echo "Especificando solo un parametro a $scrname -m"
      echo "$scrname -m #"
      echo -e "Resultado:#\n"
      echo "Para una lista detallada de los constructores y de otros modos de"
      echo "usar $scrname pruebe $scrname -h ó $scrname --help."
      echo "Para obtener informacion aún más detallada: info $scrname ó man $scrname"
      return 1
    elif
      (( $# == 2 )); then # Si solo se da un argumeto luego de la opcion -m
      P="$2"              # este se toma como unico caracter del prompt
    fi                    # De no ser asi (se dan mas de 1 argumento luego de -m)
    space="$2"            # Entonces se usa el 1 parametro (despues de -m) como caracter de espacio
                          # Y se procesan los siguientes parametros
    shift 2 # Saca los n primeros argumentos argumentos
    while (( $# > 0 )); do
      let i=1
      while [[ $(echo $1 | awk '{print NR}') -eq i ]] ; do # Repetir hasta que no haya argumentos
        aux=$(echo $1 | awk '{print $'$i'}') # Esto separa una palabra con espacios a ambos lados
        case $aux in                         # Y se la asigna a aux
          # Colores!!!

          # Foreground                                        Background
          normal)     P="$P""$base""0m\]" ;;       bnormal)    P="$P""$base""40m\]" ;;
          white)      P="$P""$base""1;37m\]" ;;
          black)      P="$P""$base""30m\]" ;;
          darkgray)   P="$P""$base""1;30m\]" ;;
          red)        P="$P""$base""31m\]" ;;      bred)       P="$P""$base""41m\]" ;;
          lbred)      P="$P""$base""1;31m\]" ;;
          green)      P="$P""$base""32m\]" ;;      bgreen)     P="$P""$base""42m\]" ;;
          lbgreen)    P="$P""$base""1;32m\]" ;;
          brown)      P="$P""$base""33m\]" ;;      bbrown)     P="$P""$base""43m\]" ;;
          yellow)     P="$P""$base""1;33m\]" ;;
          blue)       P="$P""$base""34m\]" ;;      bblue)      P="$P""$base""44m\]" ;;
          lbblue)     P="$P""$base""1;34m\]" ;;
          purple)     P="$P""$base""35m\]" ;;      bpurple)    P="$P""$base""45m\]" ;;
          lbpurple)   P="$P""$base""1;35m\]" ;;
          cyan)       P="$P""$base""36m\]" ;;      bcyan)      P="$P""$base""46m\]" ;;
          lbcyan)     P="$P""$base""1;36m\]" ;;
          lightgray)  P="$P""$base""37m\]" ;;      blightgray) P="$P""$base""47m\]" ;;

          # Efectos de texto !!! :-o

          underscore) P="$P""$base""4m\]" ;;       blink)     P="$P""$base""5m\]" ;;
          inverse)    P="$P""$base""7m\]" ;;       invisible) P="$P""$base""8m\]" ;;

          # Chucherias!!!

          $space)   P="$P " ;;
          bell)     P="$P\a" ;;
          host)     P="$P\h" ;;
          hostfull) P="$P\H" ;;
          jobs)     P="$P\j" ;;
          terminal) P="$P\l" ;;
          newline)  P="$P\n" ;;
          creturn)  P="$P\r" ;;
          shell)    P="$P\s" ;;
          user)     P="$P\u" ;;
          version)  P="$P\v" ;;
          realese)  P="$P\V" ;;
          wdir)     P="$P\w" ;;
          Wdir)     P="$P\W" ;;
          hisnum)   P="$P\!" ;;
          cmdnum)   P="$P\#" ;;
          exitcode) P="$P\$?" ;;
          sign)     P="$P\$" ;;
          date)     P="$P\$(date +" ;; # Queda abierto para que el usuario lo complete con
          *)        P="$P""$aux" ;;    # su formato preferido seguido por ")"
        esac
        let i=$i+1
      done
      shift
    done
    export PS1="$P"
    ;;
  -s | --save) # Guardar el prompt actual en la lista de prompts conocidos
    if [ -z $2 ]; then
      echo "Debe especificar un nombre para guardar el prompt actual"
      return 1
    fi
    let i=2
    while (( i <= $# )) ; do
      pname="$pname ""$'$i'"
      shift
    done
    [[ -f $savefile ]] || install -m u+rw-x,g-rwx,o-rwx -T /dev/null $savefile
    pnum=$(($(grep '^:' $savefile | wc -l)+1))
    echo ":$pnum:$pname:$PS1" >> $savefile
    echo "El prompt actual se ha guardado satisfactoriamente en $savefile"
    return 0
    ;;
  -b | --bashrc) # Hacer que el prompt actual sea el prompt por defecto
    ;;
  -d | --delete) # Borra un prompt de la lista
    ;;
  *) # else, case else
    echo "Opcion o argumento invalido"
    echo "Para ver brevemente las opciones de este comando usar: "
    echo "$scrname -h ó $scrname --help."
    echo "Para mas ayuda refierase al manual, man $scrname ó info $scrname"
    return 1
    ;;
esac

}
